[
  {
    "q": "Which file typically bootstraps a standalone Angular 17 application?",
    "options": [
      {
        "text": "main.ts",
        "correct": true,
        "exp": "Es el punto de entrada que invoca bootstrapApplication()."
      },
      {
        "text": "app.module.ts",
        "correct": false
      },
      {
        "text": "index.html",
        "correct": false
      },
      {
        "text": "angular.json",
        "correct": false
      }
    ],
    "level": "advanced"
  },
  {
    "q": "Which decorator declares a standalone component?",
    "options": [
      {
        "text": "@Component({standalone:true})",
        "correct": true,
        "exp": "Permite declarar un componente independiente de NgModule."
      },
      {
        "text": "@Standalone",
        "correct": false
      },
      {
        "text": "@NgModule",
        "correct": false
      },
      {
        "text": "@Injectable",
        "correct": false
      }
    ],
    "level": "advanced"
  },
  {
    "q": "What is the primary purpose of Angular Signals (introduced v16+)?",
    "options": [
      {
        "text": "Provide fine-grained reactive state tracking",
        "correct": true,
        "exp": "Ofrece seguimiento de estado reactivo y granular."
      },
      {
        "text": "Replace Observables completely",
        "correct": false
      },
      {
        "text": "Perform server-side rendering",
        "correct": false
      },
      {
        "text": "Manage CSS variables",
        "correct": false
      }
    ],
    "level": "advanced"
  },
  {
    "q": "The command to create a new standalone component is:",
    "options": [
      {
        "text": "ng g c myComp --standalone",
        "correct": true,
        "exp": "Genera un componente standalone sin necesidad de módulo."
      },
      {
        "text": "ng g scomp myComp",
        "correct": false
      },
      {
        "text": "ng create standalone myComp",
        "correct": false
      },
      {
        "text": "ng g c myComp",
        "correct": false
      }
    ],
    "level": "advanced"
  },
  {
    "q": "Which RxJS function converts an Observable to a Promise in RxJS 7+?",
    "options": [
      {
        "text": "firstValueFrom()",
        "correct": true,
        "exp": "Convierte un Observable en una Promise de forma recomendada en RxJS 7+."
      },
      {
        "text": "toPromise()",
        "correct": false
      },
      {
        "text": "convertToPromise()",
        "correct": false
      },
      {
        "text": "asPromise()",
        "correct": false
      }
    ],
    "level": "basic"
  },
  {
    "q": "What CLI command starts the dev server with hot reload?",
    "options": [
      {
        "text": "ng serve",
        "correct": true,
        "exp": "Inicia el servidor de desarrollo con recarga en caliente."
      },
      {
        "text": "ng run",
        "correct": false
      },
      {
        "text": "npm start angular",
        "correct": false
      },
      {
        "text": "ng build --watch",
        "correct": false
      }
    ],
    "level": "basic"
  },
  {
    "q": "Angular's dependency injection creates services:",
    "options": [
      {
        "text": "Per injector hierarchy",
        "correct": true,
        "exp": "La creación depende de la jerarquía de inyectores, permitiendo singletons por módulo."
      },
      {
        "text": "Only once per component",
        "correct": false
      },
      {
        "text": "Every time they are used",
        "correct": false
      },
      {
        "text": "Per template",
        "correct": false
      }
    ],
    "level": "basic"
  },
  {
    "q": "To share a singleton service across lazy-loaded modules you provide it:",
    "options": [
      {
        "text": "With providedIn:\"root\"",
        "correct": true,
        "exp": "`providedIn:\"root\"` hace el servicio singleton para toda la app."
      },
      {
        "text": "In each feature module",
        "correct": false
      },
      {
        "text": "Inside a component constructor",
        "correct": false
      },
      {
        "text": "Only in AppComponent",
        "correct": false
      }
    ],
    "level": "basic"
  },
  {
    "q": "Which operator maps each emitted value to a new Observable?",
    "options": [
      {
        "text": "switchMap",
        "correct": true,
        "exp": "Mapea y se suscribe a un nuevo Observable cancelando el anterior."
      },
      {
        "text": "concat",
        "correct": false
      },
      {
        "text": "take",
        "correct": false
      },
      {
        "text": "tap",
        "correct": false
      }
    ],
    "level": "intermediate"
  },
  {
    "q": "What decorator is used for a custom structural directive?",
    "options": [
      {
        "text": "@Directive",
        "correct": true,
        "exp": "Permite crear directivas personalizadas estructurales."
      },
      {
        "text": "@Component",
        "correct": false
      },
      {
        "text": "@Pipe",
        "correct": false
      },
      {
        "text": "@Injectable",
        "correct": false
      }
    ],
    "level": "basic"
  },
  {
    "q": "Which built-in pipe formats a date?",
    "options": [
      {
        "text": "date",
        "correct": true,
        "exp": "El pipe `date` formatea fechas según patrones definidos."
      },
      {
        "text": "datetime",
        "correct": false
      },
      {
        "text": "formatDate",
        "correct": false
      },
      {
        "text": "time",
        "correct": false
      }
    ],
    "level": "basic"
  },
  {
    "q": "Angular router parameter syntax in path is:",
    "options": [
      {
        "text": "/users/:id",
        "correct": true,
        "exp": "Los parámetros de ruta se indican con `:nombre`."
      },
      {
        "text": "/users:id",
        "correct": false
      },
      {
        "text": "/users/{id}",
        "correct": false
      },
      {
        "text": "/users[$id]",
        "correct": false
      }
    ],
    "level": "basic"
  },
  {
    "q": "To navigate programmatically and replace the current history entry use:",
    "options": [
      {
        "text": "this.router.navigate([\"/home\"],{replaceUrl:true})",
        "correct": true,
        "exp": "`replaceUrl:true` sustituye la entrada actual del historial."
      },
      {
        "text": "this.router.go(\"/home\")",
        "correct": false
      },
      {
        "text": "window.location=\"/home\"",
        "correct": false
      },
      {
        "text": "router.push(\"/home\")",
        "correct": false
      }
    ],
    "level": "basic"
  },
  {
    "q": "What directive displays an element only when a condition is true?",
    "options": [
      {
        "text": "*ngIf",
        "correct": true,
        "exp": "Renderiza el elemento solo si la condición se cumple."
      },
      {
        "text": "[hidden]",
        "correct": false
      },
      {
        "text": "*ngFor",
        "correct": false
      },
      {
        "text": "[ngShow]",
        "correct": false
      }
    ],
    "level": "basic"
  },
  {
    "q": "Which CLI command creates a new Angular project with standalone APIs?",
    "options": [
      {
        "text": "ng new myApp --standalone",
        "correct": true,
        "exp": "Crea un proyecto configurado para usar standalone APIs."
      },
      {
        "text": "ng create-standalone myApp",
        "correct": false
      },
      {
        "text": "ng new-standalone myApp",
        "correct": false
      },
      {
        "text": "ng new myApp",
        "correct": false
      }
    ],
    "level": "advanced"
  },
  {
    "q": "How do you mark a property as input from a parent component?",
    "options": [
      {
        "text": "@Input()",
        "correct": true,
        "exp": "Permite recibir datos desde el componente padre."
      },
      {
        "text": "@Output()",
        "correct": false
      },
      {
        "text": "@Inject()",
        "correct": false
      },
      {
        "text": "@Prop()",
        "correct": false
      }
    ],
    "level": "basic"
  },
  {
    "q": "Which lifecycle hook runs after Angular sets data-bound properties?",
    "options": [
      {
        "text": "ngOnInit",
        "correct": true,
        "exp": "Se ejecuta después de inicializar las propiedades enlazadas."
      },
      {
        "text": "constructor",
        "correct": false
      },
      {
        "text": "ngOnChanges",
        "correct": false
      },
      {
        "text": "ngAfterContentInit",
        "correct": false
      }
    ],
    "level": "basic"
  },
  {
    "q": "Default change-detection strategy is:",
    "options": [
      {
        "text": "Default",
        "correct": true,
        "exp": "La estrategia por defecto revisa el árbol de componentes completo."
      },
      {
        "text": "OnPush",
        "correct": false
      },
      {
        "text": "Manual",
        "correct": false
      },
      {
        "text": "Detached",
        "correct": false
      }
    ],
    "level": "intermediate"
  },
  {
    "q": "To make change detection more efficient, use:",
    "options": [
      {
        "text": "ChangeDetectionStrategy.OnPush",
        "correct": true,
        "exp": "Limita la detección de cambios a inputs o eventos explícitos."
      },
      {
        "text": "ChangeDetectionStrategy.Fast",
        "correct": false
      },
      {
        "text": "OnDemand",
        "correct": false
      },
      {
        "text": "Optimized",
        "correct": false
      }
    ],
    "level": "intermediate"
  },
  {
    "q": "Which Forms module is used for reactive forms?",
    "options": [
      {
        "text": "ReactiveFormsModule",
        "correct": true,
        "exp": "Proporciona soporte para formularios reactivos en Angular."
      },
      {
        "text": "FormsReactive",
        "correct": false
      },
      {
        "text": "FormsModule",
        "correct": false
      },
      {
        "text": "AngularForms",
        "correct": false
      }
    ],
    "level": "intermediate"
  },
  {
    "q": "Validator to ensure a minimum length of 5 chars:",
    "options": [
      {
        "text": "Validators.minLength(5)",
        "correct": true,
        "exp": "Valida que la longitud mínima sea 5 caracteres."
      },
      {
        "text": "Validators.required(5)",
        "correct": false
      },
      {
        "text": "Validators.length(5)",
        "correct": false
      },
      {
        "text": "Validators.min(5)",
        "correct": false
      }
    ],
    "level": "intermediate"
  },
  {
    "q": "The async pipe automatically:",
    "options": [
      {
        "text": "Subscribes and unsubscribes to Observables",
        "correct": true,
        "exp": "Gestiona automáticamente la suscripción y cancelación."
      },
      {
        "text": "Creates Observables",
        "correct": false
      },
      {
        "text": "Converts Observables to arrays",
        "correct": false
      },
      {
        "text": "Debounces values",
        "correct": false
      }
    ],
    "level": "basic"
  },
  {
    "q": "What method cancels an RxJS subscription?",
    "options": [
      {
        "text": "unsubscribe()",
        "correct": true,
        "exp": "Método estándar para cancelar la suscripción."
      },
      {
        "text": "cancel()",
        "correct": false
      },
      {
        "text": "stop()",
        "correct": false
      },
      {
        "text": "end()",
        "correct": false
      }
    ],
    "level": "intermediate"
  },
  {
    "q": "Which testing framework ships by default with Angular CLI?",
    "options": [
      {
        "text": "Jasmine",
        "correct": true,
        "exp": "Framework de testing incluido por defecto en Angular CLI."
      },
      {
        "text": "Jest",
        "correct": false
      },
      {
        "text": "Mocha",
        "correct": false
      },
      {
        "text": "Vitest",
        "correct": false
      }
    ],
    "level": "basic"
  },
  {
    "q": "Test runner default in Angular CLI is:",
    "options": [
      {
        "text": "Karma",
        "correct": true,
        "exp": "Karma es el runner predeterminado para ejecutar pruebas."
      },
      {
        "text": "Protractor",
        "correct": false
      },
      {
        "text": "Playwright",
        "correct": false
      },
      {
        "text": "Vitest",
        "correct": false
      }
    ],
    "level": "basic"
  },
  {
    "q": "To group tests in Jasmine use:",
    "options": [
      {
        "text": "describe()",
        "correct": true,
        "exp": "Función usada para agrupar especificaciones de prueba."
      },
      {
        "text": "group()",
        "correct": false
      },
      {
        "text": "suite()",
        "correct": false
      },
      {
        "text": "testGroup()",
        "correct": false
      }
    ],
    "level": "basic"
  },
  {
    "q": "The main TypeScript config file is:",
    "options": [
      {
        "text": "tsconfig.json",
        "correct": true,
        "exp": "Archivo principal de configuración de TypeScript."
      },
      {
        "text": "angular.json",
        "correct": false
      },
      {
        "text": "package.json",
        "correct": false
      },
      {
        "text": "main.ts",
        "correct": false
      }
    ],
    "level": "intermediate"
  },
  {
    "q": "Operator that filters emissions by condition:",
    "options": [
      {
        "text": "filter",
        "correct": true,
        "exp": "Emite solo valores que cumplen la condición dada."
      },
      {
        "text": "map",
        "correct": false
      },
      {
        "text": "reduce",
        "correct": false
      },
      {
        "text": "scan",
        "correct": false
      }
    ],
    "level": "intermediate"
  },
  {
    "q": "In RxJS, which operator catches errors and returns a new Observable?",
    "options": [
      {
        "text": "catchError",
        "correct": true,
        "exp": "Intercepta errores y devuelve un nuevo Observable."
      },
      {
        "text": "handleError",
        "correct": false
      },
      {
        "text": "onError",
        "correct": false
      },
      {
        "text": "tryCatch",
        "correct": false
      }
    ],
    "level": "intermediate"
  },
  {
    "q": "Standalone apps can be bootstrapped using:",
    "options": [
      {
        "text": "bootstrapApplication()",
        "correct": true,
        "exp": "Método para iniciar apps standalone sin NgModule."
      },
      {
        "text": "bootstrapModule() only",
        "correct": false
      },
      {
        "text": "platformBrowser()",
        "correct": false
      },
      {
        "text": "startStandalone()",
        "correct": false
      }
    ],
    "level": "advanced"
  },
  {
    "q": "The CLI flag to enable strict type checking is:",
    "options": [
      {
        "text": "--strict",
        "correct": true,
        "exp": "Activa comprobaciones de tipo estrictas en la compilación."
      },
      {
        "text": "--check",
        "correct": false
      },
      {
        "text": "--typesafe",
        "correct": false
      },
      {
        "text": "--strong",
        "correct": false
      }
    ],
    "level": "basic"
  },
  {
    "q": "A feature module should export a component when:",
    "options": [
      {
        "text": "It must be used in other modules",
        "correct": true,
        "exp": "Solo si el componente se usa fuera del módulo."
      },
      {
        "text": "Always",
        "correct": false
      },
      {
        "text": "Never",
        "correct": false
      },
      {
        "text": "Only in root",
        "correct": false
      }
    ],
    "level": "basic"
  },
  {
    "q": "What command builds an optimized production bundle?",
    "options": [
      {
        "text": "ng build --configuration production",
        "correct": true,
        "exp": "Genera un paquete optimizado para producción."
      },
      {
        "text": "ng prod",
        "correct": false
      },
      {
        "text": "ng serve --prod",
        "correct": false
      },
      {
        "text": "ng deploy",
        "correct": false
      }
    ],
    "level": "intermediate"
  },
  {
    "q": "Which operator is best to combine multiple Observables and emit when all complete?",
    "options": [
      {
        "text": "forkJoin",
        "correct": true,
        "exp": "Espera a que todos los Observables completen y emite un array con sus valores finales."
      },
      {
        "text": "merge",
        "correct": false
      },
      {
        "text": "concat",
        "correct": false
      },
      {
        "text": "combineLatest",
        "correct": false
      }
    ],
    "level": "intermediate"
  },
  {
    "q": "For route guards implement:",
    "options": [
      {
        "text": "CanActivate",
        "correct": true,
        "exp": "Interfaz para decidir si se permite la navegación a una ruta."
      },
      {
        "text": "OnInit",
        "correct": false
      },
      {
        "text": "AfterViewInit",
        "correct": false
      },
      {
        "text": "DoCheck",
        "correct": false
      }
    ],
    "level": "basic"
  },
  {
    "q": "To inject a value from environment.ts use:",
    "options": [
      {
        "text": "import { environment } from ...",
        "correct": true,
        "exp": "Se importa directamente el objeto environment."
      },
      {
        "text": "process.env",
        "correct": false
      },
      {
        "text": "ENV.fetch()",
        "correct": false
      },
      {
        "text": "window.env",
        "correct": false
      }
    ],
    "level": "basic"
  },
  {
    "q": "Which command updates Angular dependencies safely?",
    "options": [
      {
        "text": "ng update",
        "correct": true,
        "exp": "Actualiza dependencias Angular siguiendo reglas de compatibilidad."
      },
      {
        "text": "npm upgrade angular",
        "correct": false
      },
      {
        "text": "ng upgrade",
        "correct": false
      },
      {
        "text": "ng refresh",
        "correct": false
      }
    ],
    "level": "intermediate"
  },
  {
    "q": "RxJS operator to retry a failed HTTP request 3 times:",
    "options": [
      {
        "text": "retry(3)",
        "correct": true,
        "exp": "Reintenta la suscripción el número de veces indicado."
      },
      {
        "text": "repeat(3)",
        "correct": false
      },
      {
        "text": "tryAgain(3)",
        "correct": false
      },
      {
        "text": "replay(3)",
        "correct": false
      }
    ],
    "level": "intermediate"
  },
  {
    "q": "In Angular 17, signals are created with:",
    "options": [
      {
        "text": "signal(initialValue)",
        "correct": true,
        "exp": "Crea un signal con el valor inicial especificado."
      },
      {
        "text": "new Signal()",
        "correct": false
      },
      {
        "text": "createSignal()",
        "correct": false
      },
      {
        "text": "BehaviorSubject()",
        "correct": false
      }
    ],
    "level": "advanced"
  },
  {
    "q": "To read a signal's value you call:",
    "options": [
      {
        "text": "mySignal()",
        "correct": true,
        "exp": "Se accede al valor actual invocando el signal como función."
      },
      {
        "text": "mySignal.value",
        "correct": false
      },
      {
        "text": "get(mySignal)",
        "correct": false
      },
      {
        "text": "mySignal.get()",
        "correct": false
      }
    ],
    "level": "advanced"
  },
  {
    "q": "Directive to set CSS styles dynamically:",
    "options": [
      {
        "text": "[ngStyle]",
        "correct": true,
        "exp": "Permite aplicar estilos de forma dinámica desde la plantilla."
      },
      {
        "text": "*ngStyle",
        "correct": false
      },
      {
        "text": "[style]",
        "correct": false
      },
      {
        "text": "ng-css",
        "correct": false
      }
    ],
    "level": "basic"
  },
  {
    "q": "The HttpClient method to send POST requests is:",
    "options": [
      {
        "text": "post()",
        "correct": true,
        "exp": "Método para enviar peticiones HTTP POST."
      },
      {
        "text": "send()",
        "correct": false
      },
      {
        "text": "create()",
        "correct": false
      },
      {
        "text": "push()",
        "correct": false
      }
    ],
    "level": "basic"
  },
  {
    "q": "For lazy loading a route you specify:",
    "options": [
      {
        "text": "loadChildren",
        "correct": true,
        "exp": "Propiedad del router para carga diferida de módulos."
      },
      {
        "text": "lazyRoute",
        "correct": false
      },
      {
        "text": "loadModule",
        "correct": false
      },
      {
        "text": "loadAsync",
        "correct": false
      }
    ],
    "level": "advanced"
  },
  {
    "q": "Angular CLI default style sheet format is:",
    "options": [
      {
        "text": "CSS",
        "correct": true,
        "exp": "El formato por defecto es CSS plano."
      },
      {
        "text": "SCSS",
        "correct": false
      },
      {
        "text": "SASS",
        "correct": false
      },
      {
        "text": "LESS",
        "correct": false
      }
    ],
    "level": "basic"
  },
  {
    "q": "Which lifecycle hook is best for subscribing to Observables after view init?",
    "options": [
      {
        "text": "ngAfterViewInit",
        "correct": true,
        "exp": "Se ejecuta tras inicializar la vista, ideal para suscripciones a elementos del DOM."
      },
      {
        "text": "ngOnInit",
        "correct": false
      },
      {
        "text": "constructor",
        "correct": false
      },
      {
        "text": "ngDoCheck",
        "correct": false
      }
    ],
    "level": "intermediate"
  },
  {
    "q": "A custom pipe class must implement:",
    "options": [
      {
        "text": "PipeTransform",
        "correct": true,
        "exp": "Interfaz obligatoria para crear pipes personalizados."
      },
      {
        "text": "PipeClass",
        "correct": false
      },
      {
        "text": "TransformPipe",
        "correct": false
      },
      {
        "text": "DoTransform",
        "correct": false
      }
    ],
    "level": "basic"
  },
  {
    "q": "Template reference variables are declared using:",
    "options": [
      {
        "text": "#variable",
        "correct": true,
        "exp": "Se definen en plantilla con la almohadilla (#)."
      },
      {
        "text": "@variable",
        "correct": false
      },
      {
        "text": "$variable",
        "correct": false
      },
      {
        "text": "ref-variable",
        "correct": false
      }
    ],
    "level": "intermediate"
  },
  {
    "q": "What keyword declares a constant at compile time?",
    "options": [
      {
        "text": "const",
        "correct": true,
        "exp": "Define una constante evaluada en tiempo de compilación."
      },
      {
        "text": "readonly",
        "correct": false
      },
      {
        "text": "static",
        "correct": false
      },
      {
        "text": "final",
        "correct": false
      }
    ],
    "level": "basic"
  },
  {
    "q": "To preload all lazy routes after app start use:",
    "options": [
      {
        "text": "PreloadAllModules",
        "correct": true,
        "exp": "Estrategia de enrutamiento para precargar todos los módulos diferidos."
      },
      {
        "text": "AllRoutesPreload",
        "correct": false
      },
      {
        "text": "PreloadLazy",
        "correct": false
      },
      {
        "text": "FullPreload",
        "correct": false
      }
    ],
    "level": "intermediate"
  },
  {
    "q": "The primary advantage of OnPush change detection is:",
    "options": [
      {
        "text": "Improved performance by checking only when inputs change",
        "correct": true,
        "exp": "Reduce el coste de detección al verificar solo cuando cambian los @Input."
      },
      {
        "text": "Automatic zone patching",
        "correct": false
      },
      {
        "text": "Always checks DOM every tick",
        "correct": false
      },
      {
        "text": "Ignores @Input changes",
        "correct": false
      }
    ],
    "level": "intermediate"
  },
  {
    "q": "Which Angular CLI command generates a route guard implementing CanActivate by default?",
    "options": [
      {
        "text": "ng g guard auth",
        "correct": true,
        "exp": "Genera un guard que por defecto implementa CanActivate."
      },
      {
        "text": "ng g canactivate auth",
        "correct": false
      },
      {
        "text": "ng g service guard auth",
        "correct": false
      },
      {
        "text": "ng create guard auth",
        "correct": false
      }
    ],
    "level": "basic"
  },
  {
    "q": "How can you enable source maps only for production builds?",
    "options": [
      {
        "text": "Set \"sourceMap\": true in the production configuration of angular.json",
        "correct": true,
        "exp": "Permite habilitar mapas de fuente solo en producción."
      },
      {
        "text": "Add --source-map flag to ng serve",
        "correct": false
      },
      {
        "text": "Use @SourceMap() decorator",
        "correct": false
      },
      {
        "text": "Set devtool: 'source-map' in tsconfig.json",
        "correct": false
      }
    ],
    "level": "intermediate"
  },
  {
    "q": "Which operator lets you perform an action without altering the emitted value?",
    "options": [
      {
        "text": "tap",
        "correct": true,
        "exp": "Ejecuta efectos secundarios sin modificar el flujo de datos."
      },
      {
        "text": "map",
        "correct": false
      },
      {
        "text": "finalize",
        "correct": false
      },
      {
        "text": "filter",
        "correct": false
      }
    ],
    "level": "basic"
  },
  {
    "q": "What Angular service is used for internationalization (i18n) date formatting?",
    "options": [
      {
        "text": "DatePipe with LOCALE_ID",
        "correct": true,
        "exp": "DatePipe utiliza el token LOCALE_ID para formatear fechas según el idioma."
      },
      {
        "text": "IntlService",
        "correct": false
      },
      {
        "text": "FormatDateService",
        "correct": false
      },
      {
        "text": "i18nDate",
        "correct": false
      }
    ],
    "level": "advanced"
  },
  {
    "q": "Which function allows you to convert an Observable to a Signal?",
    "options": [
      {
        "text": "toSignal()",
        "correct": true,
        "exp": "Convierte un Observable en un Signal reactivo."
      },
      {
        "text": "signalFromObservable()",
        "correct": false
      },
      {
        "text": "observableToSignal()",
        "correct": false
      },
      {
        "text": "createSignal()",
        "correct": false
      }
    ],
    "level": "advanced"
  },
  {
    "q": "What is the purpose of the ng-container element?",
    "options": [
      {
        "text": "Acts as a logical container without rendering an extra DOM element",
        "correct": true,
        "exp": "Sirve para agrupar directivas estructurales sin añadir nodos al DOM."
      },
      {
        "text": "Provides change detection boundaries",
        "correct": false
      },
      {
        "text": "Wraps Shadow DOM slots",
        "correct": false
      },
      {
        "text": "Creates a comment node for debugging",
        "correct": false
      }
    ],
    "level": "intermediate"
  },
  {
    "q": "How do you configure route-level providers in a standalone application?",
    "options": [
      {
        "text": "Use the providers property in Route definition",
        "correct": true,
        "exp": "Cada ruta puede declarar sus propios providers en la configuración del enrutador."
      },
      {
        "text": "Add to main.ts bootstrapApplication",
        "correct": false
      },
      {
        "text": "Include in AppComponent metadata",
        "correct": false
      },
      {
        "text": "Provide inside angular.json",
        "correct": false
      }
    ],
    "level": "advanced"
  },
  {
    "q": "Which built-in Angular validator ensures a control value matches a given regex?",
    "options": [
      {
        "text": "Validators.pattern()",
        "correct": true,
        "exp": "Valida que el valor coincida con la expresión regular proporcionada."
      },
      {
        "text": "Validators.regex()",
        "correct": false
      },
      {
        "text": "Validators.match()",
        "correct": false
      },
      {
        "text": "Validators.expression()",
        "correct": false
      }
    ],
    "level": "intermediate"
  },
  {
    "q": "What decorator marks a property to emit events to a parent component?",
    "options": [
      {
        "text": "@Output()",
        "correct": true,
        "exp": "Permite emitir eventos al componente padre mediante EventEmitter."
      },
      {
        "text": "@Input()",
        "correct": false
      },
      {
        "text": "@Emit()",
        "correct": false
      },
      {
        "text": "@Event()",
        "correct": false
      }
    ],
    "level": "basic"
  },
  {
    "q": "Which CLI command analyzes the bundle size of a production build?",
    "options": [
      {
        "text": "ng build --stats-json && npx webpack-bundle-analyzer dist/stats.json",
        "correct": true,
        "exp": "Genera un archivo de estadísticas para analizar el tamaño del bundle."
      },
      {
        "text": "ng analyze-bundle",
        "correct": false
      },
      {
        "text": "ng inspect size",
        "correct": false
      },
      {
        "text": "npm run bundle-check",
        "correct": false
      }
    ],
    "level": "basic"
  },
  {
    "q": "What is the purpose of Zone.js in Angular?",
    "options": [
      {
        "text": "Intercepts async operations to trigger change detection",
        "correct": true,
        "exp": "Permite a Angular saber cuándo ejecutar la detección de cambios."
      },
      {
        "text": "Provides RxJS scheduling",
        "correct": false
      },
      {
        "text": "Manages browser rendering",
        "correct": false
      },
      {
        "text": "Implements web workers",
        "correct": false
      }
    ],
    "level": "advanced"
  },
  {
    "q": "Which operator emits the last value emitted by the source observable upon completion?",
    "options": [
      {
        "text": "last()",
        "correct": true,
        "exp": "Emite solo el último valor antes de completar."
      },
      {
        "text": "takeLast()",
        "correct": false
      },
      {
        "text": "finalize()",
        "correct": false
      },
      {
        "text": "endWith()",
        "correct": false
      }
    ],
    "level": "basic"
  },
  {
    "q": "How do you disable Angular's default sanitization for binding HTML?",
    "options": [
      {
        "text": "Use DomSanitizer.bypassSecurityTrustHtml()",
        "correct": true,
        "exp": "Permite marcar HTML como seguro para su inserción."
      },
      {
        "text": "Set [innerHTML.sanitize]=\"false\"",
        "correct": false
      },
      {
        "text": "Use @UnsafeHtml()",
        "correct": false
      },
      {
        "text": "No built-in way exists",
        "correct": false
      }
    ],
    "level": "intermediate"
  },
  {
    "q": "Which CLI command updates Angular and RxJS to the latest compatible versions?",
    "options": [
      {
        "text": "ng update @angular/core rxjs",
        "correct": true,
        "exp": "Actualiza dependencias principales a versiones compatibles."
      },
      {
        "text": "npm upgrade angular rxjs",
        "correct": false
      },
      {
        "text": "ng upgrade core",
        "correct": false
      },
      {
        "text": "ng refresh deps",
        "correct": false
      }
    ],
    "level": "basic"
  },
  {
    "q": "What lifecycle hook is called after every change detection cycle?",
    "options": [
      {
        "text": "ngDoCheck",
        "correct": true,
        "exp": "Se ejecuta tras cada ciclo de detección de cambios."
      },
      {
        "text": "ngAfterViewChecked",
        "correct": false
      },
      {
        "text": "ngOnChanges",
        "correct": false
      },
      {
        "text": "ngAfterContentInit",
        "correct": false
      }
    ],
    "level": "intermediate"
  },
  {
    "q": "Which Angular feature enables incremental hydration for SSR apps?",
    "options": [
      {
        "text": "Angular Hydration APIs",
        "correct": true,
        "exp": "Permite rehidratar la app renderizada en servidor de forma incremental."
      },
      {
        "text": "LazyDOM",
        "correct": false
      },
      {
        "text": "ServerPreload",
        "correct": false
      },
      {
        "text": "HybridSSR",
        "correct": false
      }
    ],
    "level": "advanced"
  },
  {
    "q": "How do you share a signal value across multiple components?",
    "options": [
      {
        "text": "Provide the signal in a shared service",
        "correct": true,
        "exp": "Los signals se pueden exponer desde un servicio singleton para uso global."
      },
      {
        "text": "Declare it as a global variable",
        "correct": false
      },
      {
        "text": "Use EventEmitter globally",
        "correct": false
      },
      {
        "text": "Include in angular.json",
        "correct": false
      }
    ],
    "level": "advanced"
  },
  {
    "q": "Which testing utility waits for all asynchronous tasks to finish?",
    "options": [
      {
        "text": "fixture.whenStable()",
        "correct": true,
        "exp": "Espera a que todas las tareas asíncronas concluyan antes de continuar las pruebas."
      },
      {
        "text": "asyncComplete()",
        "correct": false
      },
      {
        "text": "waitForAsyncTasks()",
        "correct": false
      },
      {
        "text": "zoneStable()",
        "correct": false
      }
    ],
    "level": "basic"
  },
  {
    "q": "What Angular token lets you configure global app initialization logic?",
    "options": [
      {
        "text": "APP_INITIALIZER",
        "correct": true,
        "exp": "Permite ejecutar código antes de inicializar la app."
      },
      {
        "text": "APP_STARTER",
        "correct": false
      },
      {
        "text": "INIT_APP",
        "correct": false
      },
      {
        "text": "BOOT_APP",
        "correct": false
      }
    ],
    "level": "basic"
  },
  {
    "q": "Which HTTP interceptor method allows modifying outgoing requests?",
    "options": [
      {
        "text": "intercept(req, next)",
        "correct": true,
        "exp": "Permite modificar o clonar la petición antes de enviarla."
      },
      {
        "text": "handle(req)",
        "correct": false
      },
      {
        "text": "transform(req)",
        "correct": false
      },
      {
        "text": "filter(req)",
        "correct": false
      }
    ],
    "level": "basic"
  },
  {
    "q": "How do you enable standalone component dev mode performance profiling?",
    "options": [
      {
        "text": "Enable Angular DevTools extension",
        "correct": true,
        "exp": "La extensión oficial DevTools permite perfilar standalone components."
      },
      {
        "text": "Set profileStandalone:true in angular.json",
        "correct": false
      },
      {
        "text": "Use @Profile() decorator",
        "correct": false
      },
      {
        "text": "Run ng build --profile",
        "correct": false
      }
    ],
    "level": "advanced"
  },
  {
    "q": "Which RxJS operator delays emissions by a specified time?",
    "options": [
      {
        "text": "delay",
        "correct": true,
        "exp": "Retrasa las emisiones del Observable según el tiempo indicado."
      },
      {
        "text": "debounceTime",
        "correct": false
      },
      {
        "text": "timeout",
        "correct": false
      },
      {
        "text": "pause",
        "correct": false
      }
    ],
    "level": "intermediate"
  },
  {
    "q": "What is the purpose of ViewChild with static: true?",
    "options": [
      {
        "text": "Access template reference before change detection",
        "correct": true,
        "exp": "Permite acceder al elemento en ngOnInit."
      },
      {
        "text": "Keep reference immutable",
        "correct": false
      },
      {
        "text": "Enable SSR compatibility",
        "correct": false
      },
      {
        "text": "Run outside NgZone",
        "correct": false
      }
    ],
    "level": "basic"
  },
  {
    "q": "Which Angular interface is used to implement custom async validators?",
    "options": [
      {
        "text": "AsyncValidator",
        "correct": true,
        "exp": "Interfaz que define la lógica de validación asíncrona."
      },
      {
        "text": "ValidatorFnAsync",
        "correct": false
      },
      {
        "text": "FormAsync",
        "correct": false
      },
      {
        "text": "ReactiveValidator",
        "correct": false
      }
    ],
    "level": "basic"
  },
  {
    "q": "Which Angular API lets you dynamically create a component at runtime?",
    "options": [
      {
        "text": "ViewContainerRef.createComponent()",
        "correct": true,
        "exp": "Permite instanciar componentes dinámicamente en tiempo de ejecución."
      },
      {
        "text": "ComponentFactory.make()",
        "correct": false
      },
      {
        "text": "Renderer2.create()",
        "correct": false
      },
      {
        "text": "DynamicComponent()",
        "correct": false
      }
    ],
    "level": "basic"
  },
  {
    "q": "Which CLI command adds Angular Universal to enable server-side rendering?",
    "options": [
      {
        "text": "ng add @nguniversal/express-engine",
        "correct": true,
        "exp": "Instala y configura Angular Universal para SSR."
      },
      {
        "text": "ng add universal",
        "correct": false
      },
      {
        "text": "ng new --ssr",
        "correct": false
      },
      {
        "text": "npm install angular-ssr",
        "correct": false
      }
    ],
    "level": "basic"
  },
  {
    "q": "What is the purpose of the Renderer2 service?",
    "options": [
      {
        "text": "Safely manipulate DOM elements",
        "correct": true,
        "exp": "Proporciona una API segura para interactuar con el DOM sin romper la abstracción de Angular."
      },
      {
        "text": "Manage change detection",
        "correct": false
      },
      {
        "text": "Configure RxJS schedulers",
        "correct": false
      },
      {
        "text": "Perform server rendering",
        "correct": false
      }
    ],
    "level": "advanced"
  },
  {
    "q": "Which operator creates an Observable that emits sequential numbers every specified interval?",
    "options": [
      {
        "text": "interval",
        "correct": true,
        "exp": "Emite valores numéricos de forma secuencial cada cierto tiempo."
      },
      {
        "text": "timer",
        "correct": false
      },
      {
        "text": "sequence",
        "correct": false
      },
      {
        "text": "range",
        "correct": false
      }
    ],
    "level": "basic"
  },
  {
    "q": "How can you make a standalone component available for lazy loading?",
    "options": [
      {
        "text": "Export it and use loadComponent in the router",
        "correct": true,
        "exp": "Angular 15+ permite lazy load de standalone components con loadComponent."
      },
      {
        "text": "Wrap it in an NgModule",
        "correct": false
      },
      {
        "text": "Use provideLazyComponent()",
        "correct": false
      },
      {
        "text": "Set lazy:true in @Component",
        "correct": false
      }
    ],
    "level": "advanced"
  },
  {
    "q": "Which lifecycle hook runs once after content is projected into the component?",
    "options": [
      {
        "text": "ngAfterContentInit",
        "correct": true,
        "exp": "Se ejecuta después de que el contenido proyectado se haya inicializado."
      },
      {
        "text": "ngAfterViewInit",
        "correct": false
      },
      {
        "text": "ngDoCheck",
        "correct": false
      },
      {
        "text": "ngOnInit",
        "correct": false
      }
    ],
    "level": "basic"
  },
  {
    "q": "What function allows you to provide HTTP interceptors in a standalone app?",
    "options": [
      {
        "text": "provideHttpClient(withInterceptors([...]))",
        "correct": true,
        "exp": "Configura interceptores HTTP sin NgModule."
      },
      {
        "text": "bootstrapHttpInterceptors()",
        "correct": false
      },
      {
        "text": "provideInterceptors()",
        "correct": false
      },
      {
        "text": "httpInterceptorsRoot()",
        "correct": false
      }
    ],
    "level": "advanced"
  },
  {
    "q": "Which RxJS operator completes after emitting the first value?",
    "options": [
      {
        "text": "first",
        "correct": true,
        "exp": "Emite el primer valor y completa el Observable."
      },
      {
        "text": "takeLast(1)",
        "correct": false
      },
      {
        "text": "single",
        "correct": false
      },
      {
        "text": "once",
        "correct": false
      }
    ],
    "level": "intermediate"
  },
  {
    "q": "How do you specify a default value for an Angular input property?",
    "options": [
      {
        "text": "Assign a value in the property declaration",
        "correct": true,
        "exp": "Se define en la propia clase como valor inicial."
      },
      {
        "text": "Use @Default decorator",
        "correct": false
      },
      {
        "text": "Set default in @Input options",
        "correct": false
      },
      {
        "text": "Provide via constructor",
        "correct": false
      }
    ],
    "level": "intermediate"
  },
  {
    "q": "Which Angular token is used to detect the current platform ID (browser, server)?",
    "options": [
      {
        "text": "PLATFORM_ID",
        "correct": true,
        "exp": "Permite conocer el entorno de ejecución."
      },
      {
        "text": "APP_PLATFORM",
        "correct": false
      },
      {
        "text": "RUNTIME_ENV",
        "correct": false
      },
      {
        "text": "PLATFORM_ENV",
        "correct": false
      }
    ],
    "level": "intermediate"
  },
  {
    "q": "What is the role of the asyncScheduler in RxJS?",
    "options": [
      {
        "text": "Schedules tasks asynchronously using setInterval/setTimeout",
        "correct": true,
        "exp": "Programa la ejecución de tareas asíncronas."
      },
      {
        "text": "Runs observables synchronously",
        "correct": false
      },
      {
        "text": "Creates a microtask queue",
        "correct": false
      },
      {
        "text": "Handles HTTP retries",
        "correct": false
      }
    ],
    "level": "intermediate"
  },
  {
    "q": "Which CLI command generates a standalone directive?",
    "options": [
      {
        "text": "ng g directive myDir --standalone",
        "correct": true,
        "exp": "Crea una directiva independiente de NgModule."
      },
      {
        "text": "ng create directive myDir",
        "correct": false
      },
      {
        "text": "ng g sd myDir",
        "correct": false
      },
      {
        "text": "ng add directive myDir",
        "correct": false
      }
    ],
    "level": "advanced"
  },
  {
    "q": "What decorator marks a class as a dependency-injectable service?",
    "options": [
      {
        "text": "@Injectable()",
        "correct": true,
        "exp": "Indica que la clase puede ser inyectada como servicio."
      },
      {
        "text": "@Service()",
        "correct": false
      },
      {
        "text": "@Provider()",
        "correct": false
      },
      {
        "text": "@Component()",
        "correct": false
      }
    ],
    "level": "basic"
  },
  {
    "q": "Which RxJS operator emits a specified number of values in sequence?",
    "options": [
      {
        "text": "range",
        "correct": true,
        "exp": "Emite un rango de números consecutivos."
      },
      {
        "text": "interval",
        "correct": false
      },
      {
        "text": "sequence",
        "correct": false
      },
      {
        "text": "from",
        "correct": false
      }
    ],
    "level": "basic"
  },
  {
    "q": "How do you pass static data to a route in Angular?",
    "options": [
      {
        "text": "Use the data property in Route configuration",
        "correct": true,
        "exp": "Se accede a través de ActivatedRoute.data."
      },
      {
        "text": "Via queryParams only",
        "correct": false
      },
      {
        "text": "Inside component constructor",
        "correct": false
      },
      {
        "text": "Use @RouteData decorator",
        "correct": false
      }
    ],
    "level": "intermediate"
  },
  {
    "q": "Which Angular token gives access to the current locale?",
    "options": [
      {
        "text": "LOCALE_ID",
        "correct": true,
        "exp": "Se utiliza para obtener el idioma actual de la aplicación."
      },
      {
        "text": "CURRENT_LANG",
        "correct": false
      },
      {
        "text": "LANG_TOKEN",
        "correct": false
      },
      {
        "text": "APP_LANG",
        "correct": false
      }
    ],
    "level": "intermediate"
  },
  {
    "q": "What does the ng-content element enable?",
    "options": [
      {
        "text": "Content projection into a component",
        "correct": true,
        "exp": "Permite proyectar contenido hijo en un componente padre."
      },
      {
        "text": "Scoped styles",
        "correct": false
      },
      {
        "text": "Dynamic routing",
        "correct": false
      },
      {
        "text": "Change detection skipping",
        "correct": false
      }
    ],
    "level": "intermediate"
  },
  {
    "q": "Which operator repeats the source observable a specified number of times?",
    "options": [
      {
        "text": "repeat",
        "correct": true,
        "exp": "Repite la secuencia de valores el número de veces indicado."
      },
      {
        "text": "retry",
        "correct": false
      },
      {
        "text": "cycle",
        "correct": false
      },
      {
        "text": "again",
        "correct": false
      }
    ],
    "level": "basic"
  },
  {
    "q": "How do you provide a value for an InjectionToken?",
    "options": [
      {
        "text": "Use { provide: MyToken, useValue: value } in providers",
        "correct": true,
        "exp": "Forma estándar de proveer un valor a un token de inyección."
      },
      {
        "text": "Set token.value = x",
        "correct": false
      },
      {
        "text": "RegisterToken(MyToken, x)",
        "correct": false
      },
      {
        "text": "Assign in angular.json",
        "correct": false
      }
    ],
    "level": "advanced"
  },
  {
    "q": "What is the default change detection mechanism in Angular?",
    "options": [
      {
        "text": "Zone-based change detection",
        "correct": true,
        "exp": "Angular usa Zone.js para detectar cambios por defecto."
      },
      {
        "text": "Manual polling",
        "correct": false
      },
      {
        "text": "Web Worker events",
        "correct": false
      },
      {
        "text": "MutationObserver only",
        "correct": false
      }
    ],
    "level": "intermediate"
  },
  {
    "q": "Which CLI command removes an Angular service?",
    "options": [
      {
        "text": "No direct command; remove files and references manually",
        "correct": true,
        "exp": "La CLI no tiene comando de borrado de servicios."
      },
      {
        "text": "ng remove service myService",
        "correct": false
      },
      {
        "text": "ng delete s myService",
        "correct": false
      },
      {
        "text": "ng g s --delete myService",
        "correct": false
      }
    ],
    "level": "basic"
  },
  {
    "q": "What decorator is used to create a custom pipe?",
    "options": [
      {
        "text": "@Pipe()",
        "correct": true,
        "exp": "Se utiliza para definir un pipe personalizado."
      },
      {
        "text": "@Transform()",
        "correct": false
      },
      {
        "text": "@Filter()",
        "correct": false
      },
      {
        "text": "@Directive()",
        "correct": false
      }
    ],
    "level": "basic"
  },
  {
    "q": "Which function lets you manually trigger change detection in a component?",
    "options": [
      {
        "text": "ChangeDetectorRef.detectChanges()",
        "correct": true,
        "exp": "Fuerza la detección de cambios manualmente."
      },
      {
        "text": "ApplicationRef.refresh()",
        "correct": false
      },
      {
        "text": "NgZone.runDetect()",
        "correct": false
      },
      {
        "text": "ViewRef.update()",
        "correct": false
      }
    ],
    "level": "basic"
  },
  {
    "q": "How can you preload specific lazy routes selectively?",
    "options": [
      {
        "text": "Implement a custom PreloadingStrategy",
        "correct": true,
        "exp": "Permite elegir qué rutas precargar."
      },
      {
        "text": "Use PreloadAllModules",
        "correct": false
      },
      {
        "text": "Set preload:true in Route",
        "correct": false
      },
      {
        "text": "Enable routerPreload flag",
        "correct": false
      }
    ],
    "level": "intermediate"
  },
  {
    "q": "Which RxJS creation operator converts an array into an observable sequence?",
    "options": [
      {
        "text": "from",
        "correct": true,
        "exp": "Emite cada elemento del array como valor del Observable."
      },
      {
        "text": "ofArray",
        "correct": false
      },
      {
        "text": "arrayToObs",
        "correct": false
      },
      {
        "text": "sequenceFrom",
        "correct": false
      }
    ],
    "level": "basic"
  },
  {
    "q": "Which Angular function lets you bootstrap multiple standalone applications on the same page?",
    "options": [
      {
        "text": "bootstrapApplication() called multiple times",
        "correct": true,
        "exp": "Se pueden inicializar varias apps invocando bootstrapApplication en diferentes elementos raíz."
      },
      {
        "text": "multiBootstrap()",
        "correct": false
      },
      {
        "text": "platformBrowserMultiple()",
        "correct": false
      },
      {
        "text": "bootstrapModuleMulti()",
        "correct": false
      }
    ],
    "level": "advanced"
  },
  {
    "q": "What is the purpose of the ViewEncapsulation.ShadowDom setting?",
    "options": [
      {
        "text": "Uses the browser's native Shadow DOM for style isolation",
        "correct": true,
        "exp": "Proporciona encapsulación real de estilos utilizando Shadow DOM."
      },
      {
        "text": "Applies global styles only",
        "correct": false
      },
      {
        "text": "Disables style encapsulation",
        "correct": false
      },
      {
        "text": "Forces inline CSS",
        "correct": false
      }
    ],
    "level": "advanced"
  },
  {
    "q": "Which Angular service allows dynamic translation at runtime?",
    "options": [
      {
        "text": "i18n with Transloco or ngx-translate",
        "correct": true,
        "exp": "Librerías populares como Transloco permiten traducción dinámica."
      },
      {
        "text": "LOCALE_ID",
        "correct": false
      },
      {
        "text": "IntlService",
        "correct": false
      },
      {
        "text": "LanguageProvider",
        "correct": false
      }
    ],
    "level": "basic"
  },
  {
    "q": "Which RxJS operator collects all source values and emits them as an array when complete?",
    "options": [
      {
        "text": "toArray",
        "correct": true,
        "exp": "Acumula todos los valores emitidos y los emite como un array al completar."
      },
      {
        "text": "bufferAll",
        "correct": false
      },
      {
        "text": "collect",
        "correct": false
      },
      {
        "text": "gather",
        "correct": false
      }
    ],
    "level": "basic"
  },
  {
    "q": "What Angular feature enables execution of code after every navigation end?",
    "options": [
      {
        "text": "Router.events with NavigationEnd",
        "correct": true,
        "exp": "Se suscribe a eventos del router filtrando por NavigationEnd."
      },
      {
        "text": "AfterRouteHook",
        "correct": false
      },
      {
        "text": "RouteFinishService",
        "correct": false
      },
      {
        "text": "RouterComplete()",
        "correct": false
      }
    ],
    "level": "intermediate"
  },
  {
    "q": "Which command checks Angular code formatting and linting?",
    "options": [
      {
        "text": "ng lint",
        "correct": true,
        "exp": "Ejecuta las reglas de ESLint configuradas para el proyecto."
      },
      {
        "text": "ng check-style",
        "correct": false
      },
      {
        "text": "ng verify-code",
        "correct": false
      },
      {
        "text": "ng audit",
        "correct": false
      }
    ],
    "level": "intermediate"
  },
  {
    "q": "What does the RxJS finalize operator do?",
    "options": [
      {
        "text": "Runs a callback after completion or error",
        "correct": true,
        "exp": "Permite ejecutar lógica de limpieza al finalizar el Observable."
      },
      {
        "text": "Stops emissions after first value",
        "correct": false
      },
      {
        "text": "Combines multiple streams",
        "correct": false
      },
      {
        "text": "Retries on error",
        "correct": false
      }
    ],
    "level": "intermediate"
  },
  {
    "q": "How do you access query parameters in a component?",
    "options": [
      {
        "text": "ActivatedRoute.queryParamMap",
        "correct": true,
        "exp": "Contiene un mapa de parámetros de consulta accesible como observable."
      },
      {
        "text": "Router.queryParamsDirect",
        "correct": false
      },
      {
        "text": "window.location.searchParams",
        "correct": false
      },
      {
        "text": "Route.query()",
        "correct": false
      }
    ],
    "level": "basic"
  },
  {
    "q": "Which Angular mechanism lets you dynamically load external scripts?",
    "options": [
      {
        "text": "Renderer2.createElement('script')",
        "correct": true,
        "exp": "Permite crear elementos script de forma segura."
      },
      {
        "text": "DynamicLoaderService.loadJs()",
        "correct": false
      },
      {
        "text": "ScriptManager.add()",
        "correct": false
      },
      {
        "text": "AsyncModule.load()",
        "correct": false
      }
    ],
    "level": "basic"
  },
  {
    "q": "What is the advantage of trackBy in *ngFor?",
    "options": [
      {
        "text": "Optimizes DOM updates by tracking item identity",
        "correct": true,
        "exp": "Evita recrear elementos cuando solo cambian datos internos."
      },
      {
        "text": "Preloads items",
        "correct": false
      },
      {
        "text": "Sorts data automatically",
        "correct": false
      },
      {
        "text": "Caches template rendering",
        "correct": false
      }
    ],
    "level": "intermediate"
  },
  {
    "q": "Which decorator injects the parent component instance?",
    "options": [
      {
        "text": "@Host()",
        "correct": true,
        "exp": "Permite inyectar el padre inmediato del inyector."
      },
      {
        "text": "@Parent()",
        "correct": false
      },
      {
        "text": "@Ancestor()",
        "correct": false
      },
      {
        "text": "@Root()",
        "correct": false
      }
    ],
    "level": "basic"
  },
  {
    "q": "Which RxJS operator switches to a new observable and emits values only from it?",
    "options": [
      {
        "text": "switchAll",
        "correct": true,
        "exp": "Se suscribe al último observable interno descartando los anteriores."
      },
      {
        "text": "mergeAll",
        "correct": false
      },
      {
        "text": "concatAll",
        "correct": false
      },
      {
        "text": "exhaust",
        "correct": false
      }
    ],
    "level": "basic"
  },
  {
    "q": "How can you make a component detect changes outside Angular's zone?",
    "options": [
      {
        "text": "NgZone.runOutsideAngular()",
        "correct": true,
        "exp": "Ejecuta código fuera de la detección de cambios para mejorar rendimiento."
      },
      {
        "text": "ChangeDetectorRef.detachOutside()",
        "correct": false
      },
      {
        "text": "ZoneSkip()",
        "correct": false
      },
      {
        "text": "NoAngularZone()",
        "correct": false
      }
    ],
    "level": "basic"
  },
  {
    "q": "Which CLI command shows the Angular CLI version?",
    "options": [
      {
        "text": "ng version",
        "correct": true,
        "exp": "Muestra la versión de Angular CLI y dependencias."
      },
      {
        "text": "ng cli-version",
        "correct": false
      },
      {
        "text": "ng about",
        "correct": false
      },
      {
        "text": "ng info",
        "correct": false
      }
    ],
    "level": "basic"
  },
  {
    "q": "What Angular API enables detecting when the app is stable?",
    "options": [
      {
        "text": "ApplicationRef.isStable",
        "correct": true,
        "exp": "Observable que emite cuando la app ha terminado tareas iniciales."
      },
      {
        "text": "AppReady()",
        "correct": false
      },
      {
        "text": "StableZone",
        "correct": false
      },
      {
        "text": "AppComplete",
        "correct": false
      }
    ],
    "level": "intermediate"
  },
  {
    "q": "Which operator emits a value after a specified delay and then completes?",
    "options": [
      {
        "text": "timer",
        "correct": true,
        "exp": "Emite tras un retardo y luego completa."
      },
      {
        "text": "delay",
        "correct": false
      },
      {
        "text": "wait",
        "correct": false
      },
      {
        "text": "pause",
        "correct": false
      }
    ],
    "level": "basic"
  },
  {
    "q": "How can you merge multiple HTTP GET requests and wait until all complete?",
    "options": [
      {
        "text": "forkJoin",
        "correct": true,
        "exp": "Combina varios observables y emite cuando todos completan."
      },
      {
        "text": "mergeMap",
        "correct": false
      },
      {
        "text": "concat",
        "correct": false
      },
      {
        "text": "zipLatest",
        "correct": false
      }
    ],
    "level": "basic"
  },
  {
    "q": "Which Angular directive two-way binds form inputs?",
    "options": [
      {
        "text": "[(ngModel)]",
        "correct": true,
        "exp": "Proporciona binding bidireccional entre modelo y vista."
      },
      {
        "text": "[[model]]",
        "correct": false
      },
      {
        "text": "(ngBind)",
        "correct": false
      },
      {
        "text": "ngTwoWay",
        "correct": false
      }
    ],
    "level": "basic"
  },
  {
    "q": "What service allows manual scrolling in a routed Angular app?",
    "options": [
      {
        "text": "ViewportScroller",
        "correct": true,
        "exp": "Permite controlar el scroll del viewport."
      },
      {
        "text": "ScrollService",
        "correct": false
      },
      {
        "text": "WindowScroll",
        "correct": false
      },
      {
        "text": "RouterScroll",
        "correct": false
      }
    ],
    "level": "basic"
  },
  {
    "q": "Which operator buffers emitted values until a notifier emits?",
    "options": [
      {
        "text": "buffer",
        "correct": true,
        "exp": "Acumula valores hasta que el observable notificador emite."
      },
      {
        "text": "group",
        "correct": false
      },
      {
        "text": "collectUntil",
        "correct": false
      },
      {
        "text": "hold",
        "correct": false
      }
    ],
    "level": "basic"
  },
  {
    "q": "How do you guard a route based on user roles asynchronously?",
    "options": [
      {
        "text": "Use an Auth Guard returning an Observable<boolean>",
        "correct": true,
        "exp": "El guard puede retornar un observable que emita true/false según roles."
      },
      {
        "text": "Use asyncRouter()",
        "correct": false
      },
      {
        "text": "Only with resolver",
        "correct": false
      },
      {
        "text": "RolesGuardSync",
        "correct": false
      }
    ],
    "level": "basic"
  },
  {
    "q": "Which Angular service provides low-level APIs for animations?",
    "options": [
      {
        "text": "AnimationBuilder",
        "correct": true,
        "exp": "Permite crear animaciones dinámicamente mediante código."
      },
      {
        "text": "AnimateService",
        "correct": false
      },
      {
        "text": "MotionAPI",
        "correct": false
      },
      {
        "text": "TransitionEngine",
        "correct": false
      }
    ],
    "level": "basic"
  },
  {
    "q": "How do you lazy load standalone routes using a function?",
    "options": [
      {
        "text": "loadComponent: () => import('./my.comp').then(m => m.MyComp)",
        "correct": true,
        "exp": "Permite cargar componentes standalone bajo demanda."
      },
      {
        "text": "lazyComponent()",
        "correct": false
      },
      {
        "text": "routeLazy()",
        "correct": false
      },
      {
        "text": "componentAsync()",
        "correct": false
      }
    ],
    "level": "advanced"
  },
  {
    "q": "Which RxJS operator shares a single subscription among multiple subscribers?",
    "options": [
      {
        "text": "shareReplay",
        "correct": true,
        "exp": "Comparte la suscripción y reemite valores a nuevos subscriptores."
      },
      {
        "text": "repeat",
        "correct": false
      },
      {
        "text": "publish",
        "correct": false
      },
      {
        "text": "cache",
        "correct": false
      }
    ],
    "level": "intermediate"
  },
  {
    "q": "What decorator injects data from a parent route?",
    "options": [
      {
        "text": "@Optional() with ActivatedRoute.parent",
        "correct": true,
        "exp": "Permite acceder a datos de la ruta padre si existe."
      },
      {
        "text": "@ParentData()",
        "correct": false
      },
      {
        "text": "@FromRoute()",
        "correct": false
      },
      {
        "text": "@Ancestor()",
        "correct": false
      }
    ],
    "level": "basic"
  },
  {
    "q": "Which Angular utility lets you test components with harnesses?",
    "options": [
      {
        "text": "ComponentHarness",
        "correct": true,
        "exp": "Parte de Angular CDK para pruebas de componentes."
      },
      {
        "text": "TestWrapper",
        "correct": false
      },
      {
        "text": "HarnessTester",
        "correct": false
      },
      {
        "text": "CdkTester",
        "correct": false
      }
    ],
    "level": "basic"
  },
  {
    "q": "How do you schedule change detection manually after an async task?",
    "options": [
      {
        "text": "NgZone.run()",
        "correct": true,
        "exp": "Ejecuta la lógica dentro de la zona Angular para forzar la detección."
      },
      {
        "text": "ChangeDetectorRef.manual()",
        "correct": false
      },
      {
        "text": "detectAsync()",
        "correct": false
      },
      {
        "text": "Zone.refresh()",
        "correct": false
      }
    ],
    "level": "intermediate"
  },
  {
    "q": "Which operator accumulates emitted values and emits each intermediate result?",
    "options": [
      {
        "text": "scan",
        "correct": true,
        "exp": "Acumula y emite cada estado intermedio."
      },
      {
        "text": "reduce",
        "correct": false
      },
      {
        "text": "accumulate",
        "correct": false
      },
      {
        "text": "collect",
        "correct": false
      }
    ],
    "level": "basic"
  },
  {
    "q": "What Angular feature lets you intercept route loading to fetch data first?",
    "options": [
      {
        "text": "Resolvers",
        "correct": true,
        "exp": "Permiten cargar datos antes de activar la ruta."
      },
      {
        "text": "Guards only",
        "correct": false
      },
      {
        "text": "Preloader",
        "correct": false
      },
      {
        "text": "RouteFetch",
        "correct": false
      }
    ],
    "level": "basic"
  },
  {
    "q": "Which command creates a production build with source maps?",
    "options": [
      {
        "text": "ng build --configuration production --source-map",
        "correct": true,
        "exp": "Genera un bundle optimizado con mapas de fuente."
      },
      {
        "text": "ng build --prodMap",
        "correct": false
      },
      {
        "text": "ng prod --maps",
        "correct": false
      },
      {
        "text": "ng build --debug",
        "correct": false
      }
    ],
    "level": "intermediate"
  },
  {
    "q": "How can you reuse form validation logic across multiple forms?",
    "options": [
      {
        "text": "Create custom ValidatorFn functions",
        "correct": true,
        "exp": "Funciones ValidatorFn pueden compartirse entre formularios."
      },
      {
        "text": "Use @ReusableValidator()",
        "correct": false
      },
      {
        "text": "GlobalValidators",
        "correct": false
      },
      {
        "text": "SharedFormsModule only",
        "correct": false
      }
    ],
    "level": "intermediate"
  },
  {
    "q": "Which Angular API helps manage multiple outlets in routing?",
    "options": [
      {
        "text": "Named RouterOutlets",
        "correct": true,
        "exp": "Permite mostrar múltiples rutas en distintas áreas de la plantilla."
      },
      {
        "text": "MultiRouter",
        "correct": false
      },
      {
        "text": "OutletManager",
        "correct": false
      },
      {
        "text": "RouterZones",
        "correct": false
      }
    ],
    "level": "basic"
  },
  {
    "q": "What does the async pipe return when the observable has not emitted yet?",
    "options": [
      {
        "text": "null",
        "correct": true,
        "exp": "Devuelve null hasta que se emite el primer valor."
      },
      {
        "text": "undefined",
        "correct": false
      },
      {
        "text": "empty string",
        "correct": false
      },
      {
        "text": "false",
        "correct": false
      }
    ],
    "level": "basic"
  },
  {
    "q": "Which decorator lets you create a directive that listens to host events?",
    "options": [
      {
        "text": "@HostListener()",
        "correct": true,
        "exp": "Permite manejar eventos del elemento host."
      },
      {
        "text": "@EventHost()",
        "correct": false
      },
      {
        "text": "@Listen()",
        "correct": false
      },
      {
        "text": "@OnEvent()",
        "correct": false
      }
    ],
    "level": "basic"
  },
  {
    "q": "How do you detach change detection for a component?",
    "options": [
      {
        "text": "ChangeDetectorRef.detach()",
        "correct": true,
        "exp": "Detiene la detección automática de cambios."
      },
      {
        "text": "NgZone.detach()",
        "correct": false
      },
      {
        "text": "ChangeDetectorRef.off()",
        "correct": false
      },
      {
        "text": "ViewRef.stop()",
        "correct": false
      }
    ],
    "level": "basic"
  },
  {
    "q": "Which operator combines the latest value from the source and another observable on emission?",
    "options": [
      {
        "text": "withLatestFrom",
        "correct": true,
        "exp": "Combina el valor actual con el más reciente de otro observable."
      },
      {
        "text": "combineLatest",
        "correct": false
      },
      {
        "text": "zip",
        "correct": false
      },
      {
        "text": "join",
        "correct": false
      }
    ],
    "level": "intermediate"
  },
  {
    "q": "Which Angular directive conditionally adds or removes a template from the DOM?",
    "options": [
      {
        "text": "*ngIf",
        "correct": true,
        "exp": "Renderiza o elimina el elemento según una condición."
      },
      {
        "text": "[hidden]",
        "correct": false
      },
      {
        "text": "*ngFor",
        "correct": false
      },
      {
        "text": "*ngSwitch",
        "correct": false
      }
    ],
    "level": "basic"
  },
  {
    "q": "How do you observe route parameter changes over time?",
    "options": [
      {
        "text": "ActivatedRoute.paramMap",
        "correct": true,
        "exp": "Es un observable que emite en cada cambio de parámetro."
      },
      {
        "text": "Router.params()",
        "correct": false
      },
      {
        "text": "RouteObserver",
        "correct": false
      },
      {
        "text": "watchParams()",
        "correct": false
      }
    ],
    "level": "intermediate"
  },
  {
    "q": "Which Angular service allows dynamic component instantiation in a view?",
    "options": [
      {
        "text": "ComponentFactoryResolver",
        "correct": true,
        "exp": "Resuelve fábricas de componentes para creación dinámica."
      },
      {
        "text": "DynamicLoader",
        "correct": false
      },
      {
        "text": "ViewService",
        "correct": false
      },
      {
        "text": "TemplateFactory",
        "correct": false
      }
    ],
    "level": "basic"
  },
  {
    "q": "What command lists outdated npm packages in an Angular project?",
    "options": [
      {
        "text": "npm outdated",
        "correct": true,
        "exp": "Muestra las dependencias que tienen versiones más recientes."
      },
      {
        "text": "ng outdated",
        "correct": false
      },
      {
        "text": "npm check",
        "correct": false
      },
      {
        "text": "ng list outdated",
        "correct": false
      }
    ],
    "level": "basic"
  },
  {
    "q": "Which operator ignores emissions for a duration after emitting a value?",
    "options": [
      {
        "text": "throttleTime",
        "correct": true,
        "exp": "Emite el primer valor y luego ignora el resto durante el tiempo especificado."
      },
      {
        "text": "debounceTime",
        "correct": false
      },
      {
        "text": "sampleTime",
        "correct": false
      },
      {
        "text": "delayWhen",
        "correct": false
      }
    ],
    "level": "intermediate"
  },
  {
    "q": "How do you configure global date locale for Angular Material components?",
    "options": [
      {
        "text": "Provide MAT_DATE_LOCALE token",
        "correct": true,
        "exp": "Configura el idioma para los componentes de fecha."
      },
      {
        "text": "Use LOCALE_ID only",
        "correct": false
      },
      {
        "text": "Set in angular.json",
        "correct": false
      },
      {
        "text": "MAT_LOCALE_ID",
        "correct": false
      }
    ],
    "level": "basic"
  },
  {
    "q": "Which Angular feature allows injection of platform-specific implementations?",
    "options": [
      {
        "text": "InjectionToken with different providers per platform",
        "correct": true,
        "exp": "Permite registrar distintos providers según la plataforma."
      },
      {
        "text": "PlatformSwitch()",
        "correct": false
      },
      {
        "text": "AppPlatformService",
        "correct": false
      },
      {
        "text": "EnvInjector",
        "correct": false
      }
    ],
    "level": "intermediate"
  }
]